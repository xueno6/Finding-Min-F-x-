# Finding-Min-F-x-

一个为了求函数极小值的项目

在branh-master下的是利用随机游走寻找适合初值的梯度下降方法

其中
main.m 文件里


delta=abs(x-x_old);

if delta(1)<0.05
    x(1)=x(1)+(rand-0.5)*0.1;
    if x(1)>33.9404 || x(1)<-0.2339
        x(1)=0.4;
    end
end
if delta(2)<0.05
    x(2)=x(2)+(rand-0.5)*0.2;
    if x(2)<-0.1513 || x(2)>0.2439
        x(2)=0.12;
    end
end


目的：

对于已知初值x = [4e-1;0.12;1.5e-1;4e9;1e-5;4e-3;5e-12;9.5]; 
但根据梯度下降搜索情况（搜索范围很小）和x在各个维度的范围，
可以推测函数很有可能上下波动剧烈且有多个极小值点。

如果单纯地使用梯度下降方法很可能陷入局部最优当中，所以我们要引入随机数来改变初值。

随机数的期望要满足两方面要求

1 随机数不能太小，因为太小会导致依然在局部最优范围内

2 随机数不能太大，超出范围会越界

所以根据梯度下降的终值和初始值差的二倍来选择随机数范围

主要main.m 函数并不能保证一次取得最优解，但在期望上会，正如投一次硬币不能保证一定会有正面，但投一万次极有可能有一个正面。

附目前得到的最小值点

%x=[-0.1;-0.01;0.15;4000000000.00000;1.0000000000000e-05;0.00400000000000000;5.00000000000000e-12;9.50000000000000]

%x=[18.2183246425871;-0.0502910181963702;0.15;4000000000;1e-05;0.004;5e-12;9.5];

补充说明：各个参数如何取以及如何调参

1 终值和初始值差的二倍来选择随机数范围？ 随机数范围的选取总而言之是一个效率问题而非根本问题，随机数取小了，可能一次跳不出“谷底”，但多取几次也有可能。所以我们选择最有效的范围。假设x(i)的定义域

范围是[a,b]，如果一次完整的梯度下降后初始值x_0和最终值x_final差别不大，例如 | x_0 - x_final |< | b - a | * 5%，可以直接取|b-a| * 10%  ~  |b-a| * 20%

作为随机数范围。

2 对于某一变量如何选取ep? 

  可以这样进行尝试：
  1）在函数FR_conjugate的第一个 x=x + alpha * d 处设置断点，运行[x_new,~]=FR_conjugate(...)。

  2）按F10查看x前后变化情况和此时 alpha 的数量级，通常，如果x(i)的定义域在10^(k-1) ~ 10^k 范围内波动，alpha * d 处于 10^(k-2) 的范围是较好的。
  
另外请注意：函数diff_h调用的是equation函数而非equationfft，主要是前者数量级大利于出现导数近似，当然后者也可以用，需要调参而已。如果对equationfft作根本性修改，这里也应该改变。

——————————————————————————————————————————————————————————————————————————————————————
7.16日更新

极小值点：          
          5.73338323092498
         0.131346053797741
                      0.15
                4000000000
                     1e-05
                     0.004
                     5e-12
                       9.5
result=92

